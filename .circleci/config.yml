main_branch: &main_branch
  filters:
    branches:
      only: main
feature_branch: &feature_branch
  filters:
    branches:
      ignore: main

version: 2.1

orbs:
  hmpps: ministryofjustice/hmpps@11
  slack: circleci/slack@4.12.5

parameters:
  alerts-slack-channel:
    type: string
    # Normally team specific alert channel e.g. hmpps_tech_alerts, syscon-alerts, dps_sed_alerts
    # This is to avoid a general alert dumping ground that no-one then monitors
    default: launchpad-alerts-nonprod

  releases-slack-channel:
    type: string
    # Normally dps-releases for most teams / projects
    default: prisoner_facing_services_releases

  node-version:
    type: string
    default: 22.13-browsers

  test-environment:
    type: string
    description: "Environment to run tests against: test (localhost), dev, staging, preprod, prod"
    default: "test"

jobs:
  build:
    executor:
      name: hmpps/node
      tag: << pipeline.parameters.node-version >>
    steps:
      - checkout
      - run:
          name: Update npm
          command: 'sudo npm install -g npm@latest'
      - restore_cache:
          key: dependency-cache-{{ checksum "package-lock.json" }}
      - run:
          name: Install Dependencies
          command: npm ci --no-audit
      - save_cache:
          key: dependency-cache-{{ checksum "package-lock.json" }}
          paths:
            - node_modules
            - ~/.cache
      - run:
          command: |
            npm run build
            DATE=$(date '+%Y-%m-%d')
            export BUILD_NUMBER=${DATE}.${CIRCLE_BUILD_NUM}
            export GIT_REF="$CIRCLE_SHA1"
            npm run record-build-info
      - run: # Run linter after build because the integration test code depend on compiled typescript...
          name: Linter check
          command: npm run lint
      - persist_to_workspace:
          root: .
          paths:
            - node_modules
            - build-info.json
            - build
            - dist
            - .cache/Cypress

  unit_test:
    executor:
      name: hmpps/node
      tag: << pipeline.parameters.node-version >>
    steps:
      - checkout
      - restore_cache:
          key: dependency-cache-{{ checksum "package-lock.json" }}
      - run:
          name: unit tests
          command: npm run test:ci
      - store_test_results:
          path: test_results
      - store_artifacts:
          path: test_results/unit-test-reports.html

  integration_test:
    executor:
      name: hmpps/node_redis
      node_tag: << pipeline.parameters.node-version >>
      redis_tag: "6.2"
    steps:
      - checkout
      - attach_workspace:
          at: ~/app
      - run:
          name: Install missing OS dependency
          command: sudo apt-get install libxss1
      - restore_cache:
          key: dependency-cache-{{ checksum "package-lock.json" }}
      - run:
          name: Get wiremock
          command: curl -o wiremock.jar https://repo1.maven.org/maven2/com/github/tomakehurst/wiremock-standalone/2.27.1/wiremock-standalone-2.27.1.jar
      - run:
          name: Run wiremock
          command: |
            echo "üöÄ Starting WireMock with monitoring..."
            nohup java -jar wiremock.jar --port 9091 --bind-address 0.0.0.0 --verbose > wiremock-startup.log 2>&1 &
            WIREMOCK_PID=$!
            echo "WireMock started with PID: $WIREMOCK_PID"
            echo $WIREMOCK_PID > wiremock.pid
            
            # Brief wait to catch immediate startup failures
            sleep 3
            if ! kill -0 $WIREMOCK_PID 2>/dev/null; then
              echo "‚ùå WireMock process died immediately after startup!"
              echo "=== WireMock Startup Log ==="
              cat wiremock-startup.log || echo "No startup log available"
              exit 1
            else
              echo "‚úÖ WireMock process still running after 3 seconds"
            fi
      - run:
          name: Initialize services and stubs
          command: |
            chmod +x scripts/wait-for-services.sh
            # Use bash explicitly for better CI compatibility
            if bash scripts/wait-for-services.sh; then
              echo "‚úÖ Services and stubs initialized successfully"
            else
              echo "‚ùå Service initialization failed"
              exit 1
            fi
      - run:
          name: Run the node app.
          command: npm run start-feature
          background: true
      - run:
          name: Wait for node app to start
          command: |
            echo "Waiting for application to start..."
            # Simple wait since stubs are already initialized
            APP_READY=false
            for i in {1..15}; do
              if curl -f -s --connect-timeout 5 "http://localhost:3000/health" > /dev/null; then
                echo "‚úÖ Application health check passed after ${i} attempts"
                APP_READY=true
                break
              elif curl -f -s --connect-timeout 5 "http://localhost:3000/" > /dev/null; then
                echo "‚úÖ Application root endpoint responding after ${i} attempts"
                APP_READY=true
                break
              fi
              echo "‚è≥ Waiting for app health check (attempt $i/15)..."
              sleep 3
            done
            
            if [ "$APP_READY" = false ]; then
              echo "‚ùå Application failed to start after 15 attempts"
              echo "Checking what's running on port 3000:"
              netstat -tlnp | grep :3000 || echo "No process on port 3000"
              echo "Checking application logs:"
              ps aux | grep node || echo "No node processes found"
              exit 1
            fi
            
            # Final connectivity test
            echo "Final connectivity verification:"
            curl -I "http://localhost:3000/" || echo "Warning: Root endpoint not accessible"
            curl -I "http://localhost:3000/health" || echo "Warning: Health endpoint not accessible"
            
            # Also check WireMock status after app startup
            echo "WireMock status after app startup:"
            if curl -f -s --connect-timeout 3 "http://localhost:9091/__admin/health" > /dev/null; then
              echo "‚úÖ WireMock still responding after app startup"
            else
              echo "‚ö†Ô∏è WireMock not responding after app startup - this may cause issues later"
              if [ -f wiremock.pid ]; then
                WIREMOCK_PID=$(cat wiremock.pid)
                if kill -0 $WIREMOCK_PID 2>/dev/null; then
                  echo "   WireMock process (PID: $WIREMOCK_PID) still running but not responding"
                else
                  echo "   WireMock process (PID: $WIREMOCK_PID) has died"
                fi
              fi
            fi
      - run:
          name: Set environment for tests
          command: |
            TEST_ENV="<< pipeline.parameters.test-environment >>"
            echo "export TEST_ENV=\"$TEST_ENV\"" >> "$BASH_ENV"
            echo "Testing against environment: $TEST_ENV"
            
            # Dynamic localhost detection for CI
            LOCALHOST_URL="http://localhost:3000"
            
            # Verify local app is actually running and get the correct port
            echo "=== Dynamic Localhost Detection ==="
            for PORT in 3000 3001 3002 8080 8081; do
              if curl -s --connect-timeout 2 "http://localhost:$PORT/health" > /dev/null 2>&1; then
                LOCALHOST_URL="http://localhost:$PORT"
                echo "‚úÖ Found running app on port $PORT"
                break
              elif curl -s --connect-timeout 2 "http://localhost:$PORT/" > /dev/null 2>&1; then
                LOCALHOST_URL="http://localhost:$PORT"
                echo "‚úÖ Found running app on port $PORT (no health endpoint)"
                break
              else
                echo "‚ùå No app found on port $PORT"
              fi
            done
            
            echo "Detected localhost URL: $LOCALHOST_URL"
            
            # Default to localhost for CI, but allow override for manual testing
            case "$TEST_ENV" in
              "dev")
                if [ -n "$DEV_INGRESS_URL" ] && [ "$DEV_INGRESS_URL" != "$LOCALHOST_URL" ]; then
                  TARGET_URL="$DEV_INGRESS_URL"
                  echo "export DEV_INGRESS_URL=\"$TARGET_URL\"" >> "$BASH_ENV"
                  echo "Using remote DEV environment: $TARGET_URL"
                else
                  TARGET_URL="$LOCALHOST_URL"
                  echo "export TEST_INGRESS_URL=\"$TARGET_URL\"" >> "$BASH_ENV"
                  echo "Using dynamic localhost for DEV: $TARGET_URL"
                fi
                ;;
              "staging")
                if [ -n "$STAGING_INGRESS_URL" ] && [ "$STAGING_INGRESS_URL" != "$LOCALHOST_URL" ]; then
                  TARGET_URL="$STAGING_INGRESS_URL"
                  echo "export STAGING_INGRESS_URL=\"$TARGET_URL\"" >> "$BASH_ENV"
                  echo "Using remote STAGING environment: $TARGET_URL"
                else
                  TARGET_URL="$LOCALHOST_URL"
                  echo "export TEST_INGRESS_URL=\"$TARGET_URL\"" >> "$BASH_ENV"
                  echo "Using dynamic localhost for STAGING: $TARGET_URL"
                fi
                ;;
              "test"|*)
                TARGET_URL="$LOCALHOST_URL"
                echo "export TEST_INGRESS_URL=\"$TARGET_URL\"" >> "$BASH_ENV"
                echo "Using dynamic localhost environment: $TARGET_URL"
                ;;
            esac
            
            echo "Environment parameter: $TEST_ENV"
            echo "Target URL: $TARGET_URL"
            source "$BASH_ENV"
      - run:
          name: Dynamic environment connectivity check
          command: |
            echo "=== Dynamic Environment Connectivity Check ==="
            
            # Re-detect the localhost URL to ensure consistency
            DETECTED_URL=""
            for PORT in 3000 3001 3002 8080 8081; do
              if curl -s --connect-timeout 2 "http://localhost:$PORT/health" > /dev/null 2>&1; then
                DETECTED_URL="http://localhost:$PORT"
                echo "‚úÖ Confirmed app running on port $PORT"
                break
              elif curl -s --connect-timeout 2 "http://localhost:$PORT/" > /dev/null 2>&1; then
                DETECTED_URL="http://localhost:$PORT"
                echo "‚úÖ Confirmed app running on port $PORT (no health endpoint)"
                break
              fi
            done
            
            if [ -n "$DETECTED_URL" ]; then
              echo "=== Testing Detected Local App ==="
              echo "Detected URL: $DETECTED_URL"
              
              # Test health endpoint
              echo "Health check:"
              curl -f "$DETECTED_URL/health" 2>/dev/null && echo "‚úÖ Health check passed" || echo "‚ùå Health check failed"
              
              # Test homepage
              echo "Homepage check:"
              curl -I "$DETECTED_URL/" 2>/dev/null && echo "‚úÖ Homepage accessible" || echo "‚ùå Homepage failed"
              
              # Test specific endpoints
              echo "Testing common endpoints:"
              for ENDPOINT in "/ping" "/status" "/ready"; do
                if curl -s --connect-timeout 2 "$DETECTED_URL$ENDPOINT" > /dev/null 2>&1; then
                  echo "‚úÖ $ENDPOINT endpoint available"
                fi
              done
            else
              echo "‚ùå No running app detected on common ports"
              echo "Checking what's running on localhost:"
              netstat -tlnp 2>/dev/null | grep ":3000\|:3001\|:3002\|:8080\|:8081" || echo "No services found on expected ports"
            fi
            
            # If testing against remote environment, also check that
            if [[ "$TARGET_URL" != "$DETECTED_URL" ]] && [[ "$TARGET_URL" =~ ^https?:// ]]; then
              echo "=== Remote Environment Check ==="
              echo "Also testing connectivity to: $TARGET_URL"
              
              # Extract hostname from target URL
              if [[ "$TARGET_URL" =~ https?://([^/]+) ]]; then
                HOSTNAME="${BASH_REMATCH[1]}"
                echo "Target hostname: $HOSTNAME"
                
                # Test DNS resolution
                echo "DNS resolution test:"
                nslookup "$HOSTNAME" || echo "DNS resolution failed"
                
                # Test basic connectivity
                echo "Basic connectivity test:"
                curl -I --connect-timeout 10 --max-time 30 "$TARGET_URL" || echo "HTTP connectivity failed"
                
                # Test Microsoft login endpoint
                echo "Microsoft login endpoint test:"
                curl -I --connect-timeout 10 --max-time 30 "https://login.microsoftonline.com/" || echo "Microsoft login unreachable"
              fi
            fi
      - run:
          name: Pre-test connectivity verification
          command: |
            echo "=== Pre-Test Connectivity Verification ==="
            
            # Verify app is still running
            if ! curl -f -s --connect-timeout 5 "http://localhost:3000/health" > /dev/null; then
              echo "‚ùå App not responding on health endpoint, attempting restart..."
              
              # Kill any existing node processes
              pkill -f "node.*dist/server.js" || true
              sleep 2
              
              # Restart the app
              npm run start-feature &
              APP_PID=$!
              echo "Started app with PID: $APP_PID"
              
              # Wait for restart
              for i in {1..20}; do
                if curl -f -s --connect-timeout 5 "http://localhost:3000/health" > /dev/null; then
                  echo "‚úÖ App restarted successfully after ${i} attempts"
                  break
                fi
                sleep 3
              done
            else
              echo "‚úÖ App is responding normally"
            fi
            
            # Verify WireMock is still running
            if ! curl -f -s --connect-timeout 5 "http://localhost:9091/__admin/health" > /dev/null; then
              echo "‚ùå WireMock not responding - investigating why it stopped..."
              
              # Investigate why WireMock stopped working
              echo "üîç WireMock Process Investigation:"
              # Only match actual Java processes running wiremock.jar, not bash scripts mentioning it
              WIREMOCK_PIDS=$(pgrep -f "java.*wiremock.jar" || true)
              if [ -n "$WIREMOCK_PIDS" ]; then
                echo "   ‚úÖ WireMock processes still running: $WIREMOCK_PIDS"
                echo "   üîç Process details:"
                # Handle multiple PIDs correctly for ps command
                echo "$WIREMOCK_PIDS" | while read -r pid; do
                  if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                    ps -p "$pid" -o pid,ppid,etime,cmd 2>/dev/null || echo "   Process $pid details unavailable"
                  fi
                done
                echo "   üîç This suggests network/connectivity issue, not process death"
              else
                echo "   ‚ùå No WireMock processes found - process died unexpectedly"
                echo "   üîç Checking system logs for crash information..."
                dmesg | grep -i "killed\|oom" | tail -5 || echo "   No crash info in dmesg"
              fi
              
              echo "   üîç Port 9091 status:"
              netstat -tlnp | grep :9091 || echo "   Port 9091 not in use"
              
              echo "   üîç System resources:"
              free -h || echo "   Memory info unavailable"
              df -h . || echo "   Disk info unavailable"
              
              # Before restarting, check if WireMock is actually broken or just temporarily unresponsive
              echo "üîç Checking if WireMock recovery is possible..."
              sleep 2  # Brief wait in case it's just temporary network hiccup
              
              if curl -f -s --connect-timeout 3 "http://localhost:9091/__admin/health" > /dev/null; then
                echo "‚úÖ WireMock recovered on its own - no restart needed!"
              else
                echo "‚ùå WireMock still not responding - attempting gentle restart..."
                
                # First, try to check if WireMock process exists
                # Only match actual Java processes, not bash scripts
                WIREMOCK_PIDS=$(pgrep -f "java.*wiremock.jar" || true)
                if [ -n "$WIREMOCK_PIDS" ]; then
                  echo "Found existing WireMock processes: $WIREMOCK_PIDS"
                  # Kill processes safely, one by one to avoid the error we saw
                  echo "$WIREMOCK_PIDS" | while read -r pid; do
                    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                      # Double-check this is actually a Java process before killing
                      if ps -p "$pid" -o cmd --no-headers 2>/dev/null | grep -q "java.*wiremock.jar"; then
                        echo "Stopping WireMock process $pid..."
                        kill -TERM "$pid" 2>/dev/null || echo "Process $pid already stopped"
                      else
                        echo "Skipping process $pid (not a WireMock Java process)"
                      fi
                    fi
                  done
                  sleep 3
                  # Force kill any remaining processes
                  echo "$WIREMOCK_PIDS" | while read -r pid; do
                    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                      # Double-check this is actually a Java process before force killing
                      if ps -p "$pid" -o cmd --no-headers 2>/dev/null | grep -q "java.*wiremock.jar"; then
                        echo "Force stopping WireMock process $pid..."
                        kill -KILL "$pid" 2>/dev/null || true
                      else
                        echo "Skipping force kill of process $pid (not a WireMock Java process)"
                      fi
                    fi
                  done
                else
                  echo "No existing WireMock processes found"
                fi
                
                # Wait a bit longer for cleanup
                sleep 5
                
                # Check if port is still in use
                if netstat -tlnp | grep -q ":9091"; then
                  echo "‚ö†Ô∏è Port 9091 still in use, waiting for cleanup..."
                  sleep 5
                fi
                
                # Restart WireMock with explicit logging
                echo "üîÑ Starting WireMock with explicit configuration..."
                nohup java -jar wiremock.jar --port 9091 --bind-address 0.0.0.0 --verbose > wiremock.log 2>&1 &
                WIREMOCK_PID=$!
                echo "Started WireMock with PID: $WIREMOCK_PID"
                
                # Store PID for potential cleanup
                echo $WIREMOCK_PID > wiremock.pid
                
                # Wait longer for WireMock to fully start
                WIREMOCK_READY=false
                for i in {1..20}; do
                  if curl -f -s --connect-timeout 3 "http://localhost:9091/__admin/health" > /dev/null 2>&1; then
                    echo "‚úÖ WireMock restarted successfully after ${i} attempts"
                    WIREMOCK_READY=true
                    break
                  fi
                  echo "‚è≥ Waiting for WireMock restart (attempt $i/20)..."
                  sleep 3
                done
                
                if [ "$WIREMOCK_READY" = false ]; then
                  echo "‚ö†Ô∏è WireMock restart failed, checking logs..."
                  if [ -f wiremock.log ]; then
                    echo "=== WireMock Log (last 20 lines) ==="
                    tail -20 wiremock.log || echo "Could not read wiremock.log"
                  fi
                  echo "Continuing without WireMock restart..."
                else
                  echo "‚úÖ WireMock restart completed successfully"
                  # Re-initialize basic stubs after successful restart
                  echo "üé≠ Re-initializing WireMock stubs after restart..."
                  if bash scripts/wait-for-services.sh; then
                    echo "‚úÖ Stub re-initialization successful"
                  else
                    echo "‚ö†Ô∏è Stub re-initialization failed, continuing anyway..."
                  fi
                fi
              fi
            else
              echo "‚úÖ WireMock is responding normally"
            fi
            
            echo "=== Environment Status Summary ==="
            APP_STATUS=$(curl -f -s --connect-timeout 2 'http://localhost:3000/health' > /dev/null && echo 'OK' || echo 'FAIL')
            WIREMOCK_STATUS=$(curl -f -s --connect-timeout 2 'http://localhost:9091/__admin/health' > /dev/null && echo 'OK' || echo 'FAIL')
            echo "App (3000): $APP_STATUS"
            echo "WireMock (9091): $WIREMOCK_STATUS"
            
            # Fail the build if app is not responding (critical)
            if [ "$APP_STATUS" = "FAIL" ]; then
              echo "‚ùå CRITICAL: Main application not responding - failing build"
              exit 1
            fi
            
            # Continue with warning if WireMock is not responding (tests may still work with mocked external services)
            if [ "$WIREMOCK_STATUS" = "FAIL" ]; then
              echo "‚ö†Ô∏è WARNING: WireMock not responding - some tests may fail but continuing..."
              echo "üîç WireMock troubleshooting information:"
              echo "   - Process check: $(pgrep -f wiremock.jar || echo 'No WireMock processes')"
              echo "   - Port check: $(netstat -tlnp | grep :9091 || echo 'Port 9091 not in use')"
              if [ -f wiremock.log ]; then
                echo "   - Log file exists: $(wc -l < wiremock.log) lines"
              else
                echo "   - No wiremock.log file found"
              fi
            fi
      - run:
          name: integration tests
          command: |
            echo "Starting integration tests with verified connectivity..."
            npm run int-test
      - store_test_results:
          path: test_results
      - store_artifacts:
          path: integration-tests/videos
      - store_artifacts:
          path: integration-tests/screenshots

workflows:
  version: 2
  build-test-and-deploy:
    jobs:
      - build:
          filters:
            tags:
              ignore: /.*/
      - unit_test:
          requires:
            - build
      - integration_test:
          context: hmpps-common-vars
          requires:
            - build
      - hmpps/helm_lint:
          name: helm_lint
      - hmpps/build_docker:
          name: build_docker

      - request-dev-preview-approval:
          <<: *feature_branch
          type: approval
          requires:
            - helm_lint
            - unit_test
            - integration_test
            - build_docker
      - hmpps/deploy_env:
          <<: *feature_branch
          name: deploy_dev_preview
          env: "dev"
          jira_update: true
          pipeline_id: <<pipeline.id>>
          pipeline_number: <<pipeline.number>>
          context: hmpps-common-vars
          requires:
            - request-dev-preview-approval
          helm_timeout: 5m
      - request-staging-preview-approval:
          <<: *feature_branch
          type: approval
          requires:
            - deploy_dev_preview
      - hmpps/deploy_env:
          <<: *feature_branch
          name: deploy_staging_preview
          env: "staging"
          jira_update: true
          jira_env_type: staging
          pipeline_id: <<pipeline.id>>
          pipeline_number: <<pipeline.number>>
          context:
            - hmpps-common-vars
            - hmpps-launchpad-home-ui-stage
          requires:
            - request-staging-preview-approval
          helm_timeout: 5m

      - hmpps/deploy_env:
          <<: *main_branch
          name: deploy_dev
          env: "dev"
          jira_update: true
          pipeline_id: <<pipeline.id>>
          pipeline_number: <<pipeline.number>>
          context: hmpps-common-vars
          requires:
            - helm_lint
            - unit_test
            - integration_test
            - build_docker
          helm_timeout: 5m
      - request-staging-approval:
          <<: *main_branch
          type: approval
          requires:
            - deploy_dev
      - hmpps/deploy_env:
          <<: *main_branch
          name: deploy_staging
          env: "staging"
          jira_update: true
          jira_env_type: staging
          pipeline_id: <<pipeline.id>>
          pipeline_number: <<pipeline.number>>
          context:
            - hmpps-common-vars
            - hmpps-launchpad-home-ui-stage
          requires:
            - request-staging-approval
      - request-preprod-approval:
          <<: *main_branch
          type: approval
          requires:
            - deploy_staging
      - hmpps/deploy_env:
          <<: *main_branch
          name: deploy_preprod
          env: "preprod"
          jira_update: true
          jira_env_type: staging
          pipeline_id: <<pipeline.id>>
          pipeline_number: <<pipeline.number>>
          context:
            - hmpps-common-vars
            - hmpps-launchpad-home-ui-preprod
          requires:
            - request-preprod-approval
          helm_timeout: 5m
      - request-prod-approval:
          <<: *main_branch
          type: approval
          requires:
            - deploy_preprod
      - hmpps/deploy_env:
          <<: *main_branch
          name: deploy_prod
          env: "prod"
          jira_update: true
          jira_env_type: production
          slack_notification: true
          slack_channel_name: << pipeline.parameters.releases-slack-channel >>
          pipeline_id: <<pipeline.id>>
          pipeline_number: <<pipeline.number>>
          context:
            - hmpps-common-vars
            - hmpps-launchpad-home-ui-prod
          requires:
            - request-prod-approval
          helm_timeout: 5m

  security:
    triggers:
      - schedule:
          cron: "30 5 * * 1-5"
          filters:
            branches:
              only:
                - main
    jobs:
      - hmpps/npm_security_audit:
          slack_channel: << pipeline.parameters.alerts-slack-channel >>
          context:
            - hmpps-common-vars
      - hmpps/trivy_latest_scan:
          slack_channel: << pipeline.parameters.alerts-slack-channel >>
          context:
            - hmpps-common-vars
      - hmpps/veracode_pipeline_scan:
          slack_channel: << pipeline.parameters.alerts-slack-channel >>
          context:
            - veracode-credentials
            - hmpps-common-vars
  security-weekly:
    triggers:
      - schedule:
          cron: "0 5 * * 1"
          filters:
            branches:
              only:
                - main
    jobs:
      - hmpps/veracode_policy_scan:
          slack_channel: << pipeline.parameters.alerts-slack-channel >>
          context:
            - veracode-credentials
            - hmpps-common-vars
