name: Integration tests
on:
  workflow_call:
    inputs:
      node_version_file:
        description: "Passed to setup-node action to specify where to source the version of node from"
        required: false
        type: string
        default: ".nvmrc"
permissions:
  contents: read
jobs:
  integration_test:
    runs-on: ubuntu-latest
    services:
      redis:
        image: redis:7.0
        ports:
          - 6379:6379
        options: --health-cmd="redis-cli ping" --health-interval=10s --health-timeout=5s --health-retries=5
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js ${{ inputs.node_version_file }}
        uses: actions/setup-node@v4
        with:
          node-version-file: ${{ inputs.node_version_file }}
      - name: download artifacts
        uses: actions/download-artifact@v4
        with:
          name: npm_build_artifacts
      - name: restore cache
        id: restore-cache
        uses: actions/cache/restore@v4
        env:
          cache-name: node-modules
        with:
          path: |
            ./node_modules
            ~/.cache/Cypress
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json', '!**/node_modules/**') }}
      - name: Init testing framework if necessary
        run: npm run int-test-init:ci --if-present
      - name: Get wiremock
        shell: bash
        run: |
          curl -o wiremock.jar https://repo1.maven.org/maven2/org/wiremock/wiremock-standalone/3.9.1/wiremock-standalone-3.9.1.jar
      - name: Prepare and run integration tests
        id: integration-tests
        shell: bash
        env:
          MS_USERNAME: ${{ secrets.MS_USERNAME }}
          MS_PASSWORD: ${{ secrets.MS_PASSWORD }}
          SYSTEM_CLIENT_ID: ${{ secrets.SYSTEM_CLIENT_ID }}
          SYSTEM_CLIENT_SECRET: ${{ secrets.SYSTEM_CLIENT_SECRET }}
          LAUNCHPAD_API_CLIENT_ID: ${{ secrets.LAUNCHPAD_API_CLIENT_ID }}
          LAUNCHPAD_API_CLIENT_SECRET: ${{ secrets.LAUNCHPAD_API_CLIENT_SECRET }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
          HOST: 0.0.0.0
          PORT: 3000
          REDIS_HOST: redis
          REDIS_PORT: 6379
        run: |
          # Start wiremock and wait for it to be ready
          echo "Starting wiremock on port 9091..."
          nohup java -jar wiremock.jar --port 9091 > wiremock.log 2>&1 &
          WIREMOCK_PID=$!
          
          # Wait for wiremock to be ready (up to 30 seconds)
          echo "Waiting for wiremock to be ready..."
          for i in {1..30}; do
            if curl -sf http://127.0.0.1:9091/__admin/health > /dev/null 2>&1; then
              echo "Wiremock is ready after ${i} seconds"
              break
            fi
            if [ "$i" -eq 30 ]; then
              echo "Wiremock failed to start within 30 seconds"
              echo "=== Wiremock logs ==="
              cat wiremock.log
              exit 1
            fi
            sleep 1
          done

          # Set up basic wiremock stubs for health checks
          echo "Setting up basic wiremock stubs..."
          curl -X POST http://127.0.0.1:9091/__admin/mappings \
            -H "Content-Type: application/json" \
            -d '{
              "request": {
                "method": "GET",
                "urlPattern": "/auth/health/ping"
              },
              "response": {
                "status": 200,
                "headers": {
                  "Content-Type": "text/plain"
                },
                "body": "pong"
              }
            }'
          
          curl -X POST http://127.0.0.1:9091/__admin/mappings \
            -H "Content-Type: application/json" \
            -d '{
              "request": {
                "method": "GET", 
                "urlPattern": "/verification/health/ping"
              },
              "response": {
                "status": 200,
                "headers": {
                  "Content-Type": "text/plain"
                },
                "body": "pong"
              }
            }'
          
          echo "Wiremock stubs configured successfully"
          
          # Verify stubs are working
          echo "Testing wiremock stubs..."
          AUTH_PING=$(curl -s http://127.0.0.1:9091/auth/health/ping)
          VERIFICATION_PING=$(curl -s http://127.0.0.1:9091/verification/health/ping)
          
          if [ "$AUTH_PING" = "pong" ] && [ "$VERIFICATION_PING" = "pong" ]; then
            echo "✅ Wiremock stubs verified working"
          else
            echo "❌ Wiremock stubs not working properly"
            echo "Auth ping response: '$AUTH_PING'"
            echo "Verification ping response: '$VERIFICATION_PING'"
            exit 1
          fi

          # Start the Node.js app
          echo "Starting Node.js app..."
          echo "Environment check before starting app:"
          echo "HOST=${HOST}"
          echo "PORT=${PORT}"
          echo "NODE_ENV=${NODE_ENV}"
          
          # Ensure HOST is set to 0.0.0.0 for CI
          export HOST=0.0.0.0
          export PORT=3000
          
          nohup npm run start-feature > server.log 2>&1 &
          APP_PID=$!
          echo "Started Node.js app with PID: $APP_PID"
          
          # Give app a moment to start
          sleep 5
          
          # Test connectivity between app and wiremock while app is starting
          echo "Testing connectivity from app's perspective..."
          echo "Can reach wiremock auth: $(curl -s http://127.0.0.1:9091/auth/health/ping || echo "FAILED")"
          echo "Can reach wiremock verification: $(curl -s http://127.0.0.1:9091/verification/health/ping || echo "FAILED")"
          
          # Check if process is still running
          if kill -0 $APP_PID 2>/dev/null; then
            echo "Node.js app process is running"
          else
            echo "ERROR: Node.js app process died immediately"
            echo "=== Server logs (immediate failure) ==="
            cat server.log
            exit 1
          fi
          
          # Wait for the Node.js app to be ready (up to 60 seconds)
          echo "Waiting for Node.js app to be ready on port 3000..."
          
          # First, let's see what's in the server logs immediately
          echo "=== Initial server logs (first 10 lines) ==="
          head -n 10 server.log || echo "No server logs yet"
          
          for i in {1..60}; do
            # Test if process is still running
            if ! kill -0 $APP_PID 2>/dev/null; then
              echo "ERROR: Node.js app process died after ${i} seconds"
              echo "=== Server logs (process died) ==="
              cat server.log
              exit 1
            fi
            
            # Test health endpoint and verify it's actually healthy
            HEALTH_RESPONSE=$(curl -s http://127.0.0.1:3000/health 2>&1)
            CURL_EXIT_CODE=$?
            
            if [ $CURL_EXIT_CODE -eq 0 ] && echo "$HEALTH_RESPONSE" | grep -q '"healthy": true'; then
              echo "Node.js app is healthy after ${i} seconds"
              echo "Health check response: $HEALTH_RESPONSE"
              break
            elif [ $CURL_EXIT_CODE -eq 0 ] && echo "$HEALTH_RESPONSE" | grep -q '"healthy": false'; then
              echo "Node.js app responding but unhealthy after ${i} seconds (will retry)"
              echo "Health response: $HEALTH_RESPONSE"
            elif [ $CURL_EXIT_CODE -ne 0 ]; then
              echo "Cannot connect to Node.js app after ${i} seconds (curl exit code: $CURL_EXIT_CODE)"
              echo "Curl error: $HEALTH_RESPONSE"
            else
              echo "Unexpected health response after ${i} seconds"
              echo "Response: $HEALTH_RESPONSE"
            fi
            
            # Show progress every 10 seconds and check server logs
            if [ $((i % 10)) -eq 0 ]; then
              echo "=== Progress check at ${i} seconds ==="
              echo "Process status: $(kill -0 $APP_PID 2>/dev/null && echo "running" || echo "dead")"
              echo "Port status: $(netstat -tlnp | grep :3000 || echo "port not bound")"
              echo "Recent server logs:"
              tail -n 5 server.log || echo "No recent logs"
              echo "========================"
            fi
            if [ "$i" -eq 60 ]; then
              echo "Node.js app failed to start within 60 seconds"
              echo "=== Server logs ==="
              cat server.log
              echo "=== Process status ==="
              ps aux | grep -E "(node|java)" | grep -v grep
              echo "=== Network status ==="
              netstat -tlnp | grep -E ":3000|:9091" || echo "No processes on ports 3000 or 9091"
              echo "=== Testing different connection methods ==="
              curl -v http://127.0.0.1:3000/health || echo "127.0.0.1:3000 failed"
              curl -v http://localhost:3000/health || echo "localhost:3000 failed"  
              curl -v http://0.0.0.0:3000/health || echo "0.0.0.0:3000 failed"
              exit 1
            fi
            sleep 1
          done

          # Run the integration tests
          echo "Running integration tests..."
          npm run int-test
      - name: cleanup processes
        if: ${{ always() }}
        run: |
          echo "Cleaning up background processes..."
          pkill -f "wiremock" || true
          pkill -f "node.*dist/server.js" || true
          echo "=== Final server logs (last 50 lines) ==="
          tail -n 50 server.log || echo "No server logs found"
      - name: upload results
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v4
        with:
          name: npm_integration_test_artifacts
          path: |
            integration_tests/videos/
            integration_tests/screenshots/
            coverage/
            test_results/
            ctrf/
            server.log
            wiremock.log
      - name: publish test report
        if: ${{ !cancelled() && github.event.repository.visibility == 'public' }}
        uses: dorny/test-reporter@v2
        with:
          artifact: npm_integration_test_artifacts
          name: Test Report
          path: 'test_results/**/*.xml'
          reporter: java-junit
          fail-on-empty: false
          fail-on-error: false
          list-suites: 'failed'
          list-tests: 'failed'
      - name: fail the action if the tests failed
        if: ${{ steps.integration-tests.outcome == 'failure' }}
        uses: actions/github-script@v7
        with:
          script: |
            core.setFailed('Integration tests failed')
